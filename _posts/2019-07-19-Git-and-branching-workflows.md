---           
layout: post
title: Git and branching workflows
date: 2019-07-19 07:26:48 UTC
updated: 2019-07-19 07:26:48 UTC
comments: false
categories: CI/CD git Gitflow product delivery
---
<div class="separator" style="clear: both; text-align: center;"></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-ofEan6TGyM0/XTC0t8jlgoI/AAAAAAAAFqI/3PxMfRDjgqAvpDw32lCX9-VOhBS8rBcrwCLcBGAs/s1600/git.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="666" data-original-width="1600" height="266" src="https://1.bp.blogspot.com/-ofEan6TGyM0/XTC0t8jlgoI/AAAAAAAAFqI/3PxMfRDjgqAvpDw32lCX9-VOhBS8rBcrwCLcBGAs/s640/git.png" width="640" /></a></div><br /><br /><h2>Introduction</h2>When you are working in a software project, one of the most important aspects is your branching strategy. If you are using GIT (and if don't, probably you should consider it), there are several strategies, such as Gitflow, Github flow and Gitlab flow, etc.<br /><br />In this article, I will try to introduce them and analyse pros and cons for each one. Spoiler alert, there are advantages and disadvantages for all of them, so taking that into account, you should consider which one fits better for your project and team.<br /><h2>Environments and software life-cycle</h2>First of all, in order to understand why we need a particular branching strategy, we need to have clear which is the relationships between versioning, environments and software life-cycle.<br /><br />Normally, in software development, we can find three environments, where we will be deploying our versions for different purposes. These can be more than three, but lets focus on the basic pipeline. I will call those environments "Dev", "Test" and "Production" (although there are other conventions like "Dev", "Staging" and "Stable").<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-c-HWf445OBY/XTC5huQrphI/AAAAAAAAFqY/297IPC9awUg4eHzjo5fHN91kLe_7wEe_gCLcBGAs/s1600/dev_test_prod.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="101" data-original-width="533" height="120" src="https://1.bp.blogspot.com/-c-HWf445OBY/XTC5huQrphI/AAAAAAAAFqY/297IPC9awUg4eHzjo5fHN91kLe_7wEe_gCLcBGAs/s640/dev_test_prod.png" width="640" /></a></div><br /><h3>Dev Environment&nbsp;</h3>Dev is the environment for development. If we are using CI/CD, each commit should be automatically deployed here. Normally, in Dev environment we can deploy and test functionally that we are currently developing for next version.<br /><br /><h3>Test Environment</h3>Test environment is used when we have a particular version, which we are planning to release. In test environment, we should execute more intensive testing and fix the issues we find to make this release stable for production. In Test environment QA's will have a very relevant role. This environment is also known as Pre-Production, Release, QA, etc.<br /><br /><h3>Production Environment</h3>Production environment is the environment that our final users will see and use. For this reason, if we find a bug in this environment and it is really critical for our users, we should hotfix that bug to sort it out as soon as possible.<br /><br />So all versions that we deliver follow the flow Dev -&gt; Test -&gt; Production.<br /><h2>Gitflow</h2><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-zoegK6Ai5Tk/XTC7mmb3Y4I/AAAAAAAAFqk/c_oPuLqfesYfK_fZfw06YsaYROTfoY1xQCLcBGAs/s1600/1_9yJY7fyscWFUVRqnx0BM6A.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="860" data-original-width="1400" height="392" src="https://1.bp.blogspot.com/-zoegK6Ai5Tk/XTC7mmb3Y4I/AAAAAAAAFqk/c_oPuLqfesYfK_fZfw06YsaYROTfoY1xQCLcBGAs/s640/1_9yJY7fyscWFUVRqnx0BM6A.png" width="640" /></a></div><br /><a href="https://nvie.com/posts/a-successful-git-branching-model/">Gitflow </a>is the most known branching strategy, which tries to cover all the scenarios that we can find during our software life-cycle.<br /><br />In Gitflow there are two branches with infinite lifetime:<br /><br /><ul><li><b>Develop</b>: in this branch, the team integrate all new developments and fixes for future versions.</li><li><b>Master</b>: this branch contains the versions which are ready to deploy to production.</li></ul><br /><br />And there are also some temporary branches.<br /><br /><ul><li><b>Release</b>: this branch will contain new Releases in order to make it stable before going to production. When a new release is stable, we destroy release branch, merging the changes (if any) to master and develop.</li><li><b>Feature</b>: when we start a new development, we create a new feature branch and we destroy it when we merge it to Develop.</li><li><b>Hotfix</b>: if there is a critical bug in production, we create a temporary hotfix branch and we destroy it when we solve it, merging the changes to master and develop.</li></ul><h3>Advantages</h3><div><ul><li>There is a clear and well defined way to proceed, which cover most of the situations that we will find during our software life-cycle</li><li>There is a clear mapping between environments and branches:</li><ul><li>Develop -&gt; Dev Environment</li><li>Relese -&gt; Test Environment</li><li>Master -&gt; Production Environtment</li></ul><li>It is a well known flow broadly used.</li><li>Some tools allows you to automatise the flow configuring gitflow branches (for example SourceTree).</li><li>You are sure that your versions are following a quality process as they progress through the workflow.</li></ul><h3>Disadvantages</h3></div><div><ul><li>You need to educate your team to use branches properly.</li><li>Sometimes to you need to merge into two branches (Releases and Hotfix).</li></ul></div><br /><h2>Github flow</h2><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-mev97K9l4u8/XTC8GDkP9aI/AAAAAAAAFqs/Gf67VvBnx3QoiHlfWR1vDRMOroULWxpWQCLcBGAs/s1600/1_iHPPa72N11sBI_JSDEGxEA.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="402" data-original-width="1600" height="160" src="https://1.bp.blogspot.com/-mev97K9l4u8/XTC8GDkP9aI/AAAAAAAAFqs/Gf67VvBnx3QoiHlfWR1vDRMOroULWxpWQCLcBGAs/s640/1_iHPPa72N11sBI_JSDEGxEA.png" width="640" /></a></div><a href="https://guides.github.com/introduction/flow/">Github flow</a> is a simplified flow, which only two kind of branches:<br /><br /><ul><li><b>Master</b>: this branch has infinite lifetime and always there is a change on Master, this should be deployed.&nbsp;</li><li><b>Feature/Bugfix branch</b>: This branches are created to add a modification, and they are destroyed after merging to master.</li></ul><br /><h3>Advantages</h3><div><ul><li>Really simple flow, which works really well for open source projects.</li><li>CI/CD friendly, as you deliver each change as soon as it comes to master branch.</li></ul><div><h3>Disadvantages</h3></div></div><div><ul><li>There is not a quality assurance stage for new releases, which can be not realistic for enterprise projects.</li><li>It doesn't allow to hotfix a production version without delivering a new version from master.&nbsp;</li><li>There is not a clear matching between environments and branches, which can lead to misunderstandings.</li><li>Assuming master is free errors is not realistic and it can be risky.</li></ul></div><h2>Gitlab flow</h2><a href="https://docs.gitlab.com/ee/workflow/gitlab_flow.html">Gitlab flow </a>is a branching strategy which tries to combine the simplicity of Github flow with the environments-oriented branching strategy of Gitflow. As a result, there are several workflows, depending on the needs.<br /><br /><br /><b>Production branch with GitLab flow: </b>it is the result of adding a production branch to Github flow.<br /><br /><b><br /></b><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-gD_PLt5w0UI/XTC8dmqn6cI/AAAAAAAAFq4/yVVXHylUgOg7N_CcXGqSBVlSNVqW12rMwCLcBGAs/s1600/production_branch.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="549" data-original-width="338" height="320" src="https://1.bp.blogspot.com/-gD_PLt5w0UI/XTC8dmqn6cI/AAAAAAAAFq4/yVVXHylUgOg7N_CcXGqSBVlSNVqW12rMwCLcBGAs/s320/production_branch.png" width="197" /></a></div><h3>Advantages</h3><div><ul><li>You don't need to deploy each merge that is completed on master, which gives you more control over the delivery.</li><li>You always have a snapshot of what you have in production in production branch.</li><li>There is only one way for merges.</li></ul><div><h3>Disadvantages</h3></div><div><ul><li>There is not a Â¡release validation stage to make stable in isolation what you are going to deliver to production.</li><li>There is not a way to hotfix production branch without delivering all the changes you have on master, which can be a big limitation, depending on your delivery pipeline.</li><li>As for Github flow, you have to assume that master is free of errors, which can be not realistic.</li></ul></div><div><b>Environment branches with GitLab flow</b>: this flow proposes to have an infinite life-time branch per environment.</div></div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-fBGRi4X4AFk/XTC8Xfo-CHI/AAAAAAAAFq0/eOEsa9qHHm8Q7nx6D9PO13zHIFH45AWpwCLcBGAs/s1600/environment_branches.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="618" data-original-width="560" height="320" src="https://1.bp.blogspot.com/-fBGRi4X4AFk/XTC8Xfo-CHI/AAAAAAAAFq0/eOEsa9qHHm8Q7nx6D9PO13zHIFH45AWpwCLcBGAs/s320/environment_branches.png" width="289" /></a></div><h3>Advantages</h3><div><ul><li>There is mapping between branches and environments.&nbsp;</li></ul><div><h3>Disadvantages</h3></div><div><ul><li>Same disadvantages as for the previous approach.</li></ul></div></div><h2>Conclusions</h2>Now that you know the most relevant git branching strategy, you might know which is the one that fits for your project.<br /><br />Based on my personal experience, simple approaches like Github flow or Gitlab flow are cool for open source projects or when there is not a third party client. However, I think in those approaches there are gaps and more risk involved when it comes to enterprise projects. Even when you have a decent set of automatic testing, for enterprise projects we normally have a QA stage in order to ensure that the new release that you are delivering to your clients is stable.<br /><br />In addition, if you are not in charge of delivering timelines or you have several production clients, the concept of CI/CD per each PR will be problematic as you cannot decide what you want to deliver and when you are going to deliver a new version.<br /><br />Finally, your clients might require a hotfix for the current production version, but they don't want any new functionality. For this scenario, Gitflow is the only one which can support this by definition.