---           
layout: post
title: Managing snapshots for Amazon ElasticSearch with Dotnet Core Lambdas
date: 2020-12-13 22:30:14 UTC
updated: 2020-12-13 22:30:14 UTC
comments: false
categories: .net core 2020 Amazon AWS AWS lambda Backup ElasticSearch
---
<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-vJNWwJ_H_iA/X9aSnSQIY3I/AAAAAAAAGZs/CidKLUKxeFkEYaxkCMlt_cmYgUuIVkHKgCLcBGAsYHQ/s1200/aws-elasticsearch-1200x487.jpg" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="487" data-original-width="1200" height="261" src="https://1.bp.blogspot.com/-vJNWwJ_H_iA/X9aSnSQIY3I/AAAAAAAAGZs/CidKLUKxeFkEYaxkCMlt_cmYgUuIVkHKgCLcBGAsYHQ/w640-h261/aws-elasticsearch-1200x487.jpg" width="640" /></a></div><h1 style="text-align: left;">Introduction <br /></h1><p>It is awesome to have some useful services like <a href="https://aws.amazon.com/elasticsearch-service/">ElasticSearch managed by AWS</a>, so you don't have to care about patching, monitoring, etc.&nbsp;</p><p>When it comes to backup management for indexes, Amazon ElasticSearch includes automated snapshots. Automated snapshots are only for cluster recovery. You can use them to restore your domain in the event of red cluster status or other data loss. Amazon ES stores automated snapshots in a preconfigured Amazon S3 bucket at no additional charge. In particular, if you are using a higher version than 5.3, Amazon ElasticSearch takes hourly automated snapshots and retains up to 336 of them for 14 days.</p><p>However, this policy might not be enough if you need to keep your snapshots for a longer 15 days, or you need to take a snapshot to create a new cluster in another region, subnet, etc. If you have different requirements to manage your snapshots, you will have to work with manual snapshots. For this part, AWS does not offer a good managed experience, since the solution is calling ElasticSearch Web API, as it is explained in <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains-snapshots.html#es-managedomains-snapshot-restore">this article</a>. In fact, even for automatic snapshots, you will also have to use ElasticSearch Web API if you need to restore your index.&nbsp;</p><p>In orther to make requests to ElasticSearch, they must be signed by AWS (<a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-request-signing.html">more info here</a>). For this purpose, AWS provides packages for multiple languages (Java, Python, Ruby, Node and&nbsp; Go), but not for C#.</p><p>In this article, we will see how we can manage Amazon ElasticSearch snapshots with dotnet core.</p><h1 style="text-align: left;">Creating ElasticSearch snapshots with dotnet core</h1><p>First of all, you need to cover some pre-requisites that are detailed <a href="https://docs.aws.amazon.com/elasticsearch-service/latest/developerguide/es-managedomains-snapshots.html#es-managedomains-snapshot-restore">here</a>, as for the rest of languages:</p><ol style="text-align: left;"><li>You have to create an S3 bucket. In this S3 bucket, you won't be able to configure lifecycle policies to move to cold start or delete old data.</li><li>You have to create an IAM role with access to the S3 bucket created previously.</li><li>You need an IAM user and permissions to assume previous role or call elastic search with HTTP PUT.</li></ol><p>For the dotnet implementation, I created a new dotnet core AWS Lambda. In this way, I could invoke it from multiple sources. For example I can schedule a CloudWatch event to trigger it every day, every month, etc. The source code of this example can be found on <a href="https://github.com/albertocorrales/ElasticSearchSnapshotsLambda">this GitHub repository</a>.<br /></p> <p>First of all, this is my request object for AWS lambda input:</p><pre class="prettyprint"><code class="language-cs"><br />public class Request<br />{<br />    public string Endpoint { get; set; }<br />    public string RepositoryName { get; set; }<br />    public string S3Bucket { get; set; }<br />    public string Region { get; set; }<br />    public string RoleArn { get; set; }<br />}<br /></code></pre> <p>Then this is the lambda handler:</p><code class="language-cs"></code><pre class="prettyprint"><code class="language-cs"><br />public async Task FunctionHandler(Request request, ILambdaContext context)<br />{<br />    try<br />    {<br />        var accessKey = Environment.GetEnvironmentVariable("ACCESS_KEY");<br />        var secretKey = Environment.GetEnvironmentVariable("SECRET_KEY");<br />        var signer = new AWS4RequestSigner(accessKey, secretKey);<br />        var repositoryUrl = $"{request.Endpoint}/_snapshot/{request.RepositoryName}";<br />        var service = "es";<br /><br />        await RegisterS3Repository(request, context, signer, repositoryUrl, service);<br />        await CreateSnapshot(request, context, signer, repositoryUrl, service);<br /><br />    }<br />    catch (Exception ex)<br />    {<br />        context.Logger.LogLine($"Error performing backup: {ex.Message}");<br />        throw;<br />    }<br />}<br /></code></pre> <p>As I mentioned previously, requests to ElasticSearch have signed and this is not supported by AWS. However, there is a signer for AWS that you can use from this project: <a href="https://github.com/tsibelman/aws-signer-v4-dot-net">https://github.com/tsibelman/aws-signer-v4-dot-net</a> by using <a href="https://github.com/tsibelman/aws-signer-v4-dot-net">this NuGet package</a>. Once we create the signer with AWS access key and secret key, we just have to register the repository and create the snapshot.</p><p>In order to register the S3 repository, we have to create the request, sign it and send it with PUT http operation:</p><pre class="prettyprint"><code class="language-cs"><br />private static async Task RegisterS3Repository(Request request, ILambdaContext context, AWS4RequestSigner signer, string repositoryUrl, string service)<br />{<br />    context.Logger.LogLine($"Register ElasticSearch Repository: {request.RepositoryName}");<br />    var requestBody = new<br />    {<br />        type = "s3",<br />        settings = new<br />        {<br />            bucket = request.S3Bucket,<br />            region = request.Region,<br />            role_arn = request.RoleArn<br />        }<br />    };<br />    string requestBodyString = System.Text.Json.JsonSerializer.Serialize(requestBody);<br />    var content = new StringContent(requestBodyString, Encoding.UTF8, "application/json");<br /><br />    var httpRequestRepository = new HttpRequestMessage<br />    {<br />        Method = HttpMethod.Put,<br />        RequestUri = new Uri(repositoryUrl),<br />        Content = content<br />    };<br /><br />    httpRequestRepository = await signer.Sign(httpRequestRepository, service, request.Region);<br />    var client = new HttpClient();<br />    var responseRepository = await client.SendAsync(httpRequestRepository);<br /><br />    if (!responseRepository.IsSuccessStatusCode)<br />    {<br />        throw new Exception($"Error registering repository {request.RepositoryName}.\n" +<br />            $"Error code: {responseRepository.StatusCode}.\n" +<br />            $"Content: {await responseRepository.Content.ReadAsStringAsync()}");<br />    }<br />    context.Logger.LogLine($"ElasticSearch Repository {request.RepositoryName} successfully registered");<br />}<br /></code></pre> <p>Once we register the repository, we can create new snapshots in a similar way, signing the request and sending a PUT http operation to $"{repositoryUrl}/{snapshotName}" endpoint:</p><pre class="prettyprint" style="text-align: left;"><code class="language-cs">private static async Task CreateSnapshot(Request request, ILambdaContext context, AWS4RequestSigner signer, string repositoryUrl, string service)<br />{<br />    var snapshotName = DateTime.Now.ToString("dd-MM-yyyy-h-mm-ss").ToLower();<br /><br />    context.Logger.LogLine($"Create ElasticSearch Image: {repositoryUrl}/{snapshotName}");<br /><br />    var httpRequestSnapshot = new HttpRequestMessage<br />    {<br />        Method = HttpMethod.Put,<br />        RequestUri = new Uri($"{repositoryUrl}/{snapshotName}"),<br />        Content = null<br />    };<br /><br />    httpRequestSnapshot = await signer.Sign(httpRequestSnapshot, service, request.Region);<br />    var client = new HttpClient();<br />    var responseSnapshot = await client.SendAsync(httpRequestSnapshot);<br /><br />    if (!responseSnapshot.IsSuccessStatusCode)<br />    {<br />        throw new Exception($"Error creating snapshot {snapshotName}.\n" +<br />            $"Error code: {responseSnapshot.StatusCode}.\n" +<br />            $"Content: {await responseSnapshot.Content.ReadAsStringAsync()}");<br />    }<br />    context.Logger.LogLine($"ElasticSearch snapshot {snapshotName} successfully registered");<br />}<br /></code></pre>     <h1 style="text-align: left;">Conclusions</h1><p>In this article, we have seen the options AWS ElasticSearch offers to create snapshots. In particular, the automatic way to create snapshots is quite limited and it is not configurable, so depending on our requirements we might need to create manual snapshots.&nbsp;</p><p>If we want to implement this process with dotnet core, in this article we have seen an example to implement a lambda which we can use go create manual snapshots. We could also extend this approach to build scheduled lambdas to remove old snapshots or any other operations.</p><p>In my personal opinion, Amazon ElasticSearch should offer better alternatives, for example integration with <a href="https://aws.amazon.com/backup/">AWS Backup</a>.&nbsp;</p>