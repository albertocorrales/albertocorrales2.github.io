---           
layout: post
title: From OpenAPI to source code with CI/CD
date: 2019-12-04 22:17:06 UTC
updated: 2019-12-04 22:17:06 UTC
comments: false
categories: CI/CD NPM NuGet OpenApi typescript Web API web services
---
<div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-Er3RXxo4b1U/XayBY6Xr29I/AAAAAAAAFv4/_wAFNlHk1TALvcTH_DBfLI8bd3o_vHizgCLcBGAsYHQ/s1600/1_Qf94xFwde421J_ZSmdPJDw1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="439" data-original-width="844" height="331" src="https://1.bp.blogspot.com/-Er3RXxo4b1U/XayBY6Xr29I/AAAAAAAAFv4/_wAFNlHk1TALvcTH_DBfLI8bd3o_vHizgCLcBGAsYHQ/s640/1_Qf94xFwde421J_ZSmdPJDw1.png" width="640" /></a></div><h2>Introduction</h2>In the era of Microservices, you are probably designing or consuming one or more Web Services. As a result, you might be aware of the importance of having a good definition of your web services, since that is what clients and developers will use to know how a web service can be used.<br /><br />For that reason, you should have a clear and easy way to define and understand your Web API. In order to help you to make a good definition we have <a href="https://restfulapi.net/">REST (Representational state transfer)</a>, which is a software architectural style that defines a set of rules to create Web Services. I'm not going to go into details about RESTful, because there is enough material for a full post and it is out of the scope of this post. But I might write another post about REST, since even nowadays I see some crazy stuff when it comes to Web APIs design.<br /><br />Well, imagine we already have a really awesome definition for the resources of our Web API, and your clients are going to be really excited&nbsp;to use it, but...how do I let them know which are my endpoints, models, message errors, etc?<br /><br />In order to provide a way to define our REST APIs, in 2011 Swagger created the first version for RESTful APIs specification. Over the subsequent years, Swagger specification has been evolving. In 2017,&nbsp;the Open APIInitiative,&nbsp;under the sponsorship of the Linux Foundation, published the <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md">Open<span style="color: black;">API</span>&nbsp;Specification v3.0.0</a>, which is the consequence of the evolution of RESTful API definition and it is considered the standard to define REST APIs nowadays.<br /><br />In this article we will see the benefits of having an OpenAPI&nbsp;contract and all the possibilities that it can offer you, such as generating source code automatically form your definition and distributing it among your clients.<br /><h2>Generating your OpenAPI contract</h2>If you are working with Web Services, I strongly recommend that you follow a contract-first approach. No matter if your consumers are external to your organisation, if you define the contract first, you will have several benefits:<br /><ul><li>Separation of concerns.</li><li>Avoid blocks between teams (frontend and backend).</li><li>Good and consistent communication between teams.</li><li>A clear definition of your API from the beginning.&nbsp;</li><li>Easy documentation.</li><li>Consistent API models.</li><li>Reusability and code generation.</li><li>Easy versioning control.</li></ul>In order to define your OpenAPI contract, you can use multiple tools. However, I would like to recommend two of them, one to work locally and another to work in the cloud.<br /><h3>Generating your contract from VS Code</h3>If you prefer working offline, there is a nice extension for VS Code to edit your API definition called&nbsp;OpenAPI (Swagger) Editor (<a href="https://github.com/42Crunch/vscode-openapi">https://github.com/42Crunch/vscode-openapi</a>).<br /><br />By using this editor, you will have a GUI to edit your contract and you will have your contract edited in real time.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-nJqE5cg0sWs/XbXG3HM5WCI/AAAAAAAAFwk/RuCDnJnw_HA3Ek2qbLCYrw1jbBobMgoFwCLcBGAsYHQ/s1600/vscode.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="1030" data-original-width="1321" height="497" src="https://1.bp.blogspot.com/-nJqE5cg0sWs/XbXG3HM5WCI/AAAAAAAAFwk/RuCDnJnw_HA3Ek2qbLCYrw1jbBobMgoFwCLcBGAsYHQ/s640/vscode.PNG" width="640" /></a></div><br />By using VS commands, you will have also a list of commands that can help you to add new elements into your OpenAPI contract:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-3442dzASpJM/XbXHz9Q-1qI/AAAAAAAAFww/E2qlVFvLrykDbN0xzC50wTjnXujWt7Z1wCLcBGAsYHQ/s1600/commands.PNG" imageanchor="1"><img border="0" data-original-height="437" data-original-width="921" height="303" src="https://1.bp.blogspot.com/-3442dzASpJM/XbXHz9Q-1qI/AAAAAAAAFww/E2qlVFvLrykDbN0xzC50wTjnXujWt7Z1wCLcBGAsYHQ/s640/commands.PNG" width="640" /></a></div><br />Finally, one cool feature added recently is the security audit, which can generate a report from your contract, where all the security issues detected are reported for you:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-xb9y3hVrHoE/XbXIt4v0QmI/AAAAAAAAFw8/hBBaekOvsQooYp2W4gsPGqHzciDbj7CUwCLcBGAsYHQ/s1600/security.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="919" data-original-width="1021" height="358" src="https://1.bp.blogspot.com/-xb9y3hVrHoE/XbXIt4v0QmI/AAAAAAAAFw8/hBBaekOvsQooYp2W4gsPGqHzciDbj7CUwCLcBGAsYHQ/s400/security.PNG" width="400" /></a></div><h3>Generating your contract on the cloud</h3>If you prefer working on the cloud, the tool that I like the most is <i>apicurio </i>(<a href="https://studio.apicur.io/">https://studio.apicur.io</a>), which is also open source&nbsp;<a href="https://github.com/Apicurio/apicurio-studio">https://github.com/Apicurio/apicurio-studio</a>. With <i>apicurio</i>, you will be able to define and modify your OpenAPI contract from your favourite browser. In addition, you can invite collaborators and have a history with the changes that are made to your contract.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-7djrocO5Rok/XbXJP2o2mmI/AAAAAAAAFxE/mi-omJ9lc5Ie3Y5kE7E-uXyJcXhVrVrHgCLcBGAsYHQ/s1600/apicurio.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="856" data-original-width="1600" height="342" src="https://1.bp.blogspot.com/-7djrocO5Rok/XbXJP2o2mmI/AAAAAAAAFxE/mi-omJ9lc5Ie3Y5kE7E-uXyJcXhVrVrHgCLcBGAsYHQ/s640/apicurio.PNG" width="640" /></a></div><br />Apart from helping you with your API definition, apicurio can generate documentation from your OpenAPI contract, which can be especially interesting if you are working with third party clients or business people.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-cqPztpV-Tdo/XbXLXAT1DtI/AAAAAAAAFxU/FEk9rAzANWgo5jd1kQY9XFbJVEVhzUZzACLcBGAsYHQ/s1600/docu.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="826" data-original-width="1600" height="330" src="https://1.bp.blogspot.com/-cqPztpV-Tdo/XbXLXAT1DtI/AAAAAAAAFxU/FEk9rAzANWgo5jd1kQY9XFbJVEVhzUZzACLcBGAsYHQ/s640/docu.PNG" width="640" /></a></div><div style="margin-bottom: .0001pt; margin: 0cm;"><span style="font-size: 13.5pt;"><br /></span></div>If you want to know more about tools for editing your OpenAPI contracts, I suggest having a look at this URL:&nbsp;<a href="https://openapi.tools/#gui-editors">https://openapi.tools/#gui-editors</a><br /><h2>Generating Code from your contract</h2>Apart from having a clear definition of what your clients can expect from your API, OpenAPI contracts offer a lot of additional advantages. One advantage that I found extremely useful is generating code from your contract.<br /><br />During the latest months, I've been working in a project based on React and at the beginning the client code to consume APIs was implemented manually. As a consequence, when there was change in a service, you had to find out what part of the code you had to change to update to a newer version of the contract.<br /><br />To make things worse, the project was implemented in JavaScript. In other words, mistakes during manual updates of your API code could lead to run-time errors. Considering the fact that our client application was going to consume multiple services in constant evolution, the manual coding approach didn't seem a good option.<br /><br />One of the best contribution that we had was adding Typescript support. By using Typescript (as I analysed in my previous post&nbsp;<a href="https://www.albertocorrales.com/2019/07/benefits-of-using-typescript-in-your.html">Benefits of using TypeScript in your project</a>), one of the greatest advantages is having errors in compilation time. As a result, in spite of having manual updates for contracts, our changes were consistent through the application and real-time errors were reduced to a large extent.<br /><br />With this scenario, another improvement that I introduced is generating our code from OpenAPI contract. By doing so, we are saving a large amount of time, as no manual changes in our code are required anymore. In addition, when we update a contract for any API, we will have feedback about compilation errors if we have breaking changes, which leads to a smooth and safer maintenance of our client code.<br /><br />In order to generate your code from an OpenAPI contract, there are multiple alternatives. Particularly, we are using <i>openapi-generator</i> (<a href="https://github.com/OpenAPITools/openapi-generator">https://github.com/OpenAPITools/openapi-generator</a>), due to its multiple possibilities to be used by almost any existing framework or language.<br /><br />I personally use <i>openapi-generator</i> as an npm package, so the first step is to install the package globally:<br /><span style="background-color: #eeeeee; font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">npm install @openapitools/openapi-generator-cli -g</span><br /><br />Next, I can configure the generator to generate typescript client code with the following command:<br /><span style="background-color: #eeeeee;"><span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">openapi-generator generate -i MyOpenApiContract.json -g typescript-fetch</span></span><br /><h2>Distributing your API definition with CI/CD</h2>At this point you already know how you can generate code from your OpenAPI contract. However, in order to use that code for multiple projects, as it is likely to happen for Web APIs, you might want to pack the generated code and publish it, so all your clients will be able to get the latest version by using your packages.<br /><br />In order to make this process really easy, I came up with the idea of creating and publishing an NPM package from the source code generated by <i>openapi-generator</i>. Furthermore, I included CI/CD, so I will publish automatically a new version of my package each time I modify my contract.<br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-mp3dz2gHWXM/XdU05fz3ogI/AAAAAAAAF1E/3FJcJKREF1oHlZ9srI0ludW27WJWOtY0gCLcBGAsYHQ/s1600/Untitled%2BDiagram.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="112" data-original-width="521" src="https://1.bp.blogspot.com/-mp3dz2gHWXM/XdU05fz3ogI/AAAAAAAAF1E/3FJcJKREF1oHlZ9srI0ludW27WJWOtY0gCLcBGAsYHQ/s1600/Untitled%2BDiagram.png" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div>In my case, I'm using Azure DevOps, so I have a repository where I store my contract and my build will be triggered always that a new change is detected. During the build process, I will execute some commands that I've defined in my file <i>package.json</i>:<br /><pre class="prettyprint"><code class="language-js"><br />{<br />    "name": "my-api",<br />    "version": "1.0.0",<br />    "private": false,<br />    "repository": {<br />        "type": "git"</code><br />},<br />    "scripts": {<br />        "api-gen": "openapi-generator generate -i myapi.contract.json -g typescript-fetch",<br />        "postapi-gen": "replace-in-file GlobalFetch WindowOrWorkerGlobalScope src/**",<br />        "tsc": "rimraf ./dist/ &amp;&amp; tsc --project tsconfig.json",<br />        "posttsc": "copyfiles package.json dist"<br />    },<br />    "devDependencies": {<br />        "@openapitools/openapi-generator-cli": "^0.0.21-4.1.2",<br />        "replace-in-file": "^4.1.3",<br />        "rimraf": "^2.7.1",<br />        "tslint": "^5.20.0",<br />        "typescript": "^3.5.3",<br />        "copyfiles": "^2.1.0"<br />    }<br />}<br /></pre><br />If we have a look at my build pipeline, we can see the first two tasks, which are intended to read the version from the contract definition file and write it into my package.<br /><br />In the third step, I will install all the packages that I need to execute the following steps.<br /><br />Next, I generate my code by execute the command <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">"npm run api-gen"</span>. As you can see in the package.json definition, this step is invoking the library <i>openapi-generator</i> and subsequently, it is doing a replacement. This replacement is done because we are working with a more recent version of Typescript.<br /><br />Next, during the step "Transpile" I execute the command <span style="font-family: &quot;courier new&quot; , &quot;courier&quot; , monospace;">"npm run tsc"</span>, which transpiles the typescript code into javascript + ts definitions. Finally, I publish the results of the transpilation as a build artifact.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-YHy9gEUzKYY/XdVCXF4JWbI/AAAAAAAAF1Q/0xl90x7M8GAcq6w-5GRhcqsjlS72ixuVACLcBGAsYHQ/s1600/ci.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="734" data-original-width="766" height="613" src="https://1.bp.blogspot.com/-YHy9gEUzKYY/XdVCXF4JWbI/AAAAAAAAF1Q/0xl90x7M8GAcq6w-5GRhcqsjlS72ixuVACLcBGAsYHQ/s640/ci.PNG" width="640" /></a></div><div class="separator" style="clear: both; text-align: center;"><br /></div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">After a successful build, my release definition basically reads version of the package, concatenates the number of the build, and publishes the package as an NPM package.</div><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-dwtBaFHcxJU/XdVCXZxAe-I/AAAAAAAAF1U/CppunWztDn4OeD7TF-3E9VVhogvg4Ar6gCLcBGAsYHQ/s1600/cd.PNG" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="426" data-original-width="772" height="352" src="https://1.bp.blogspot.com/-dwtBaFHcxJU/XdVCXZxAe-I/AAAAAAAAF1U/CppunWztDn4OeD7TF-3E9VVhogvg4Ar6gCLcBGAsYHQ/s640/cd.PNG" width="640" /></a></div><h2>Conclusions</h2>In this article, we introduced OpenAPI and the importance of using contracts to define your Web APIs.<br /><br />Subsequently, we have saw how you can generate your typescript client source code from an OpenAPI contract, which can be extremely useful and can save you time developing and maintaining that code manually.<br /><br />Finally, we analysed the idea of publishing packages from your OpenAPI contract automatically, by using CI/CD. As a result, our clients will be able to get new versions of your Web API and consume it easily.<br /><br />This process can be extended, since&nbsp;<i>openapi-generator</i> supports multiple languages and server code generation, so there are a lot of scenarios that this process might cover when it comes to automatise source code generation. For example, here I showed how we can generate an NPM package, but I'm also using this process to generate and publish a dotnet Nuget package.<br /><br /><br />